<head>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: white;
    }
    #globeViz {
      width: 100vw;
      height: 100vh;
      position: absolute;
    }
  </style>

  <!-- Globe.gl -->
  <script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
</head>

<body>
  <div id="globeViz"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';
    import * as d3 from 'https://esm.sh/d3';
    import * as topojson from 'https://esm.sh/topojson-client';

    const world = new Globe(document.getElementById('globeViz'))
      .backgroundColor('rgba(0,0,0,0)')
      .showGlobe(false)
      .showAtmosphere(false);

    fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')
      .then(res => res.json())
      .then(landTopo => {
        const landFeatures = topojson.feature(landTopo, landTopo.objects.land).features;

        const positions = [];

        const projection = d3.geoEquirectangular();
        const geoPath = d3.geoPath().projection(projection);

        const samplePointsInPolygon = (feature, numPoints = 800) => {
          const bounds = geoPath.bounds(feature);
          const xMin = bounds[0][0];
          const xMax = bounds[1][0];
          const yMin = bounds[0][1];
          const yMax = bounds[1][1];

          const points = [];
          while (points.length < numPoints) {
            const x = xMin + Math.random() * (xMax - xMin);
            const y = yMin + Math.random() * (yMax - yMin);
            const [lng, lat] = projection.invert([x, y]);
            if (d3.geoContains(feature, [lng, lat])) {
              points.push([lng, lat]);
            }
          }
          return points;
        };

        landFeatures.forEach(feature => {
          const sample = samplePointsInPolygon(feature, 1000); // Anzahl Punkte pro Land
          sample.forEach(([lng, lat]) => {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;

            const radius = 100;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            positions.push(x, y, z);
          });
        });

        const pointsGeometry = new THREE.BufferGeometry();
        pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const pointsMaterial = new THREE.PointsMaterial({
          color: 000000,
          size: 1.0,
          transparent: true,
          opacity: 0.5,
          depthWrite: false
        });

        const points = new THREE.Points(pointsGeometry, pointsMaterial);

        world.scene().add(points);
      });
  </script>
</body>
